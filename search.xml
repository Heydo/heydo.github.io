<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetCode-合并二叉树]]></title>
    <url>%2F2017%2F08%2F15%2FleetCode-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[题目Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.Example 1: Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. 给定框架12345678/** * @param &#123;TreeNode&#125; t1 * @param &#123;TreeNode&#125; t2 * @return &#123;TreeNode&#125; */var mergeTrees = function(t1, t2) &#123; // 代码区&#125;; 思路一：递归法思路Javascript中定义二叉树：1234function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125; 这里的变量val指的就是当前结点的值。我们把一个大的二叉树看成一个个是只有两层的二叉树的集合。那么，我们就容易获得每一个小二叉树的根节点，而他的叶子的值又是再下一级二叉树的根节点。我们将两个二叉树根节点的和保存到第一个二叉树的根节点上：1t1.val += t2.val; 那么，合并后的左叶子节点的值，可以这样处理：将t1和t2的左叶子递归入原函数，即把两个以t1.left和t2.left为根节点的二级二叉树相加，计算出新的根节点的和赋予到上一层二叉树的左叶子t1.left。（右叶子同上）12t1.left = mergeTrees(t1.left,t2.left);t1.right = mergeTrees(t1.right,t2.right); 这样，通过递归的方法，就计算出每一层级的节点之和。那么，问题来了：如果某一个节点没有左或者右叶子，当我们访问其val属性时，自然是不存在的。所以，还要加上一个判断，当左节点存在右节点不存在时，直接返回存在节点的val，这样就避免了获取不到val属性的问题了。1234if(t1 == null) return t2;if(t2 == null) return t1; 最后返回t1。 代码12345678910var mergeTrees = function(t1, t2) &#123; if(t1 == null) return t2; if(t2 == null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1;&#125;; 结果Accepted 思路二：迭代法（待续）]]></content>
      <categories>
        <category>编程</category>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>leetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键生成Hexo文章框架]]></title>
    <url>%2F2017%2F08%2F14%2FSoftware-CreatHexoPost%2F</url>
    <content type="text"><![CDATA[程序才写完，具体明天写~]]></content>
      <categories>
        <category>编程</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode-汉明距离]]></title>
    <url>%2F2017%2F08%2F10%2FleetCode-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[从今天开始 ，把leetcode上刷的题目一边做一遍整理进来，用于日后再看。 题目 The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 &le; x, y &lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ? ? The above arrows point to positions where the corresponding bits are different. 思路一思路判断两个二进制中不同位置上不同数字的个数，容易让人想到”异或”。 异或：a⊕b = (¬a ∧ b) ∨ (a ∧¬b)如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。 例子上，1和4的异或值为”101”。然后利用除法和取余得到每一个位数，并且push到一个数组中，得到{0，1，0，1}。另：JavaScript的除法不会只保留整数，所以还需要parseInt()函数舍去小数。最后，再遍历出数组中”1”的个数。 代码12345678910111213141516171819202122/*** @param &#123;number&#125; x* @param &#123;number&#125; y* @return &#123;number&#125;*/var hammingDistance = function(x, y) &#123; var x_2 = parseInt(x.toString(2)); var y_2 = parseInt(y.toString(2)); var xor = x_2 ^ y_2; var arr = new Array(); arr.push(parseInt(xor/1000)); arr.push(parseInt(xor%1000/100)); arr.push(parseInt(xor%1000%100/10)); arr.push(parseInt(xor%1000%100%10)); var distance = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i]==1)&#123; distance = distance + 1; &#125; &#125; return distance;&#125;; 结果：失败因为在获取数组元素的时候，只考虑到了四位，所以，一旦二进制位数变大，算法就失效了。 思路二思路将“异或值”转换成字符串，然后用splite(“”)将字符串按位切割成一个数组，再进行遍历。 代码1234567891011121314151617/*** @param &#123;number&#125; x* @param &#123;number&#125; y* @return &#123;number&#125;*/var hammingDistance = function(x, y) &#123; var xor = (x ^ y).toString(2); var xor_str = xor.toString(); var arr = xor_str.split(""); var distance = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == 1)&#123; distance++; &#125; &#125; return distance;&#125;; 结果：成功一开始，竟然使用了splite(“0”)来分割，当遇到“11010”这样的数时自然就出错了。没有一开始就用splite(“”),显然是智商问题。。。 别人家的代码(待续。。。)]]></content>
      <categories>
        <category>编程</category>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-数据绑定问题]]></title>
    <url>%2F2017%2F08%2F06%2FwechatApp-DataBinding%2F</url>
    <content type="text"><![CDATA[今天微信小程序遇到一个关于数据绑定的问题：1234567onLoad: function (options) &#123; var postId = options.id; var postData = postsData.postList[postId]; //把postData绑定到上面的"data:"中 this.data.postData = postData; // console.log(this.data.postData) &#125;, 老师使用1this.data.postData = postData; 绑定数据，能够成功显示，但是我自己的demo上就绑定不到数据。 视频中的老师说： 如果在onLoad()方法中，不是异步的去执行一个数据绑定，则不需要使用this.setData方法，只需要对this.data赋值即可实现数据绑定。 当我改用this.setData方法时，可以完成需求。所以，以后所有的数据绑定都要用this.setData方法？ 这时候，出现了另外一个问题： 调用 Page.prototype.setData 频繁，可能影响性能 这个问题暂时不管，等到学习更深入再去研究。（待续。。。）]]></content>
      <categories>
        <category>编程</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-自定义属性命名]]></title>
    <url>%2F2017%2F08%2F04%2FwechatApp-dataName%2F</url>
    <content type="text"><![CDATA[这几天学习微信小程序时，遇到一个问题：12345&lt;block wx:for="&#123;&#123;posts_key&#125;&#125;" wx:for-item="item"&gt; &lt;view catchtap="onPostTap" data-postid="&#123;&#123;item.postId&#125;&#125;"&gt; &lt;template is="postItem" data="&#123;&#123;...item&#125;&#125;"&gt;&lt;/template&gt; &lt;/view&gt; &lt;/block&gt; 要传递的参数postID的自定义属性data-postid如果用驼峰命名法，写成data-postId的话。在event.currentTarget.dataset对象中是找不到的。我在网上搜到有一篇文章说，data-后面的属性名必须要全部小写。但是经过我的验证以后，应该是这样的：data-后面其实是可以加许多”-“的，例如data-post-id。这样的命名方法在event.currentTarget.dataset对象中，会被格式化为postId。综上，如果在data-后面还有”-“连接的内容时，属性名会自动被转换成驼峰命名。而data-连接着的第一部分就会变成小写，所以data-postId就会变成postid,自然就找不到这个属性了。]]></content>
      <categories>
        <category>编程</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于排序函数]]></title>
    <url>%2F2017%2F08%2F04%2Fsorting-function%2F</url>
    <content type="text"><![CDATA[慕课上的例子： 12345678&lt;script type="text/javascript"&gt;function sortNum(a,b) &#123;return a - b; //升序，如降序，把“a - b”该成“b - a”&#125;var myarr = new Array("80","16","50","6","100","1");document.write(myarr + "&lt;br&gt;");document.write(myarr.sort(sortNum));&lt;/script&gt; 首先，return 是返回一个值到函数外，在调用函数的地方能够接收这个值，在这里，return 返回的是 a-b 的值。 第二个问题，a 和 b 是怎么回事。 我们看到 sortNum 函数的调用形式， 1myarr.sort(sortNum) 是将 sortNum 作为参数传到 sort 函数中，而 sort 函数是系统自带的数组函数，由系统实现函数功能。 sortNum 函数要带两个参数也是系统所规定好的，在进行排序时，系统会按顺序（从下标 0 一个个往后），将数组中的元素作为 a 和 b 参数传入 sortNum 中。 比如，数组myarr，第一次传入下标 0 元素 myarr[0] 作为 a，下标 1 元素 myarr[1] 作为 b，算出 a-b 的值，&lt;=-1 则 a 在 b 前面，==0 则顺序不变，&gt;=1 则 b 在前 a 在后。比较完 myarr[0] 和 myarr[1]，向后移一位，进行 myarr[1] 和 myarr[2] 的比较，这时，myarr[1] 是 a，myarr[2] 是 b，以此类推。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
