{"title":"leetCode-合并二叉树","slug":"leetCode-Merge-Two-Binary-Trees","date":"2017-08-15T07:08:18.000Z","updated":"2017-08-15T13:25:39.468Z","comments":true,"path":"api/articles/leetCode-Merge-Two-Binary-Trees.json","excerpt":"题目Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.<br>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.Example 1:<br>Input:<br>          Tree 1                    Tree 2<br>              1                         2<br>             / \\                       / \\<br>            3   2                     1   3<br>           /                           \\   \\<br>          5                             4   7<br>Output:<br>    Merged tree:<br>             3<br>            / \\<br>           4   5<br>          / \\   \\<br>         5   4   7<br><br>Note: The merging process must start from the root nodes of both trees.<br>","covers":null,"content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.<br>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\n<p><b>Example 1:</b></p>\n<p><pre><br><b>Input:</b><br>          Tree 1                    Tree 2<br>              1                         2<br>             / \\                       / \\<br>            3   2                     1   3<br>           /                           \\   \\<br>          5                             4   7<br><b>Output:</b><br>    Merged tree:<br>             3<br>            / \\<br>           4   5<br>          / \\   \\<br>         5   4   7<br></pre><br><b>Note: </b>The merging process must start from the root nodes of both trees.<br><a id=\"more\"></a></p>\n<h1 id=\"给定框架\"><a href=\"#给定框架\" class=\"headerlink\" title=\"给定框架\"></a>给定框架</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;TreeNode&#125; t1</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123;TreeNode&#125; t2</span></div><div class=\"line\"><span class=\"comment\"> * @return &#123;TreeNode&#125;</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"keyword\">var</span> mergeTrees = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t1, t2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码区</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h1 id=\"思路一：递归法\"><a href=\"#思路一：递归法\" class=\"headerlink\" title=\"思路一：递归法\"></a>思路一：递归法</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>Javascript中定义二叉树：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TreeNode</span>(<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.val = val;</div><div class=\"line\">      <span class=\"keyword\">this</span>.left = <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这里的变量val指的就是当前结点的值。<br>我们把一个大的二叉树看成一个个是只有两层的二叉树的集合。那么，我们就容易获得每一个小二叉树的根节点，而他的叶子的值又是再下一级二叉树的根节点。<br>我们将两个二叉树根节点的和保存到第一个二叉树的根节点上：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">t1.val += t2.val;</div></pre></td></tr></table></figure></p>\n<p>那么，合并后的左叶子节点的值，可以这样处理：<br>将t1和t2的左叶子递归入原函数，即把两个以t1.left和t2.left为根节点的二级二叉树相加，计算出新的根节点的和赋予到上一层二叉树的左叶子t1.left。（右叶子同上）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">t1.left = mergeTrees(t1.left,t2.left);</div><div class=\"line\">t1.right = mergeTrees(t1.right,t2.right);</div></pre></td></tr></table></figure></p>\n<p>这样，通过递归的方法，就计算出每一层级的节点之和。<br>那么，问题来了：如果某一个节点没有左或者右叶子，当我们访问其val属性时，自然是不存在的。所以，还要加上一个判断，当左节点存在右节点不存在时，直接返回存在节点的val，这样就避免了获取不到val属性的问题了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(t1 == <span class=\"literal\">null</span>)</div><div class=\"line\">\t<span class=\"keyword\">return</span> t2;</div><div class=\"line\"><span class=\"keyword\">if</span>(t2 == <span class=\"literal\">null</span>)</div><div class=\"line\">\t<span class=\"keyword\">return</span> t1;</div></pre></td></tr></table></figure></p>\n<p>最后返回t1。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mergeTrees = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">t1, t2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(t1 == <span class=\"literal\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> t2;</div><div class=\"line\">    <span class=\"keyword\">if</span>(t2 == <span class=\"literal\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> t1;</div><div class=\"line\">    t1.val += t2.val;</div><div class=\"line\">    t1.left = mergeTrees(t1.left, t2.left);</div><div class=\"line\">    t1.right = mergeTrees(t1.right, t2.right);</div><div class=\"line\">    <span class=\"keyword\">return</span> t1;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><strong>Accepted</strong></p>\n<h1 id=\"思路二：迭代法\"><a href=\"#思路二：迭代法\" class=\"headerlink\" title=\"思路二：迭代法\"></a>思路二：迭代法</h1><p>（待续）</p>\n","categories":[{"name":"编程","path":"api/categories/编程.json"},{"name":"leetCode","path":"api/categories/leetCode.json"}],"tags":[{"name":"javascript","path":"api/tags/javascript.json"},{"name":"leetCode","path":"api/tags/leetCode.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}